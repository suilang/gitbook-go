# 程序的基本结构

## hello，world

```go
package main

import "fmt"

func main() {
	fmt.Println("hello, world")
}
```

## 包package

包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。

一个包由一个或多个以 `.go` 为扩展名的源文件组成，文件名和包名一般来说都是不相同的。

1. 每个 Go 文件都属于且仅属于一个包。
2. 必须在源文件中非注释的第一行指明这个文件属于哪个包，如：`package utils`。
3. `package main`表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 `main` 的包。
4. 编译包名不是为 main 的源文件，如 `pack1`，编译后产生的对象文件将会是 `pack1.a` 而不是可执行程序。
5. 所有的包名都应该使用小写字母。

### 标准库

在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。

> 在 Windows 下，标准库的位置在 Go 根目录下的子目录 `pkg\windows_386` 中；在 Linux 下，标准库在 Go 根目录下的子目录 `pkg\linux_amd64` 中（如果是安装的是 32 位，则在 `linux_386` 目录中）。一般情况下，标准包会存放在 `$GOROOT/pkg/$GOOS_$GOARCH/` 目录下。

Go 的标准库包含了大量的包（如：fmt 和 os），

* **包的依赖关系决定了其构建顺序。**如果想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。
* 属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯例，**每个目录都只包含一个包。**
* **如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。**

Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 `.o` 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。

如果 `A.go` 依赖 `B.go`，而 `B.go` 又依赖 `C.go`：

* 为了编译 `A.go`, 编译器读取的是 `B.o` 而不是 `C.o`.
* 顺序为：编译 `C.go`, `B.go`, 然后是 `A.go`.

这种机制对于编译大型的项目时可以显著地提升编译速度。

### 引包

一个 Go 程序是通过 `import` 关键字将一组包链接在一起。

`import "fmt"` 告诉 Go 编译器这个程序需要使用 `fmt` 包（的函数，或其他元素），`fmt` 包实现了格式化 IO（输入/输出）的函数。

引入多个包：

```go
import "fmt"
import "os"

// 或者
import "fmt"; import "os"

// 或者
import (
   "fmt"
   "os"
)

//或者
import ("fmt"; "os")
```

查找规则：

1. 如果包名以 `./` 开头，则 Go 会在相对目录中查找；
2. 如果包名以 `/` 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。
3. 其他： `"fmt"` 或者 `"container/list"`，则 Go 会在全局文件进行查找；

导入包即等同于包含了这个包的所有的代码对象。

* 除了符号 `_`，包中所有代码对象的标识符必须是唯一的，以避免名称冲突。
* 但是相同的标识符可以在不同的包中使用，因为可以使用包名来区分它们。



